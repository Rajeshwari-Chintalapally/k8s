1.Pod:  Containers are encapsulated into a kubernates object. It is a single instance of appliaction.smallest object created in k8s.
      Single pod can have multiple containers and it should have different containers(not same).
       - additional containers use as helper container which used for if application need additional support for configurations or file processing  etc..
      Two containers communicate using local host and share volume
2.Replica: Prevent loosing access to application, will maintain more than on pod to run application. To achive high availability.
3.Replication contoller: This specifies number of specified pods create/run all time.
                       This also spin pods across nodes.
4.Replicaset: new version of replication contorller to achieve replication
            Monitors the pods health and deploy new pods if required
            Labels and selectors helps replicaSet to monitor pods. Based on labels and selectors Replicaset can identify which pods this need to monitor.
-------------------------------------------
ReplicationController is the older resource used to ensure a specified number of pod replicas are running at any time. 
It only supports equality-based selectors.

ReplicaSet is the newer, more advanced version that replaces ReplicationController. 
It supports both equality- and set-based selectors, allowing more flexible pod selection. ReplicaSet is used by Deployments to manage pods.

Summary:
ReplicaSet is the modern replacement for ReplicationController, offering more features and flexibility. 
ReplicationController is now deprecated in favor of ReplicaSet.
--------------------------------------------------------------
Equality-based selectors in Kubernetes are used to select resources (like pods) based on exact matches of label key-value pairs.            
                       
selector:
  matchLabels:
    app: nginx
This selector matches pods with the label app=nginx.

Supported operators:

= (equals)
== (equals)
!= (not equals)
Note:
Equality-based selectors do not support set-based operations like in, notin, or matching multiple values. Those are only available in set-based selectors.
---------------------------------------------------------------
5. Deployments
A Deployment in Kubernetes (k8s) is a resource object that manages a set of identical Pods, ensuring the desired number of them are running and up-to-date. Deployments are used for rolling updates, scaling, and rollback of applications.

Key Features
Declarative updates for Pods and ReplicaSets
Rollback to previous versions
Scaling up/down
Self-healing (replaces failed Pods)
----------------------------------------------------------
6. diff between deployemtns and replicase:
A Deployment and a ReplicaSet are both Kubernetes resources, but they serve different purposes:

ReplicaSet
Ensures a specified number of pod replicas are running at any time.
Only manages pod replication (creating, deleting pods).
Does not provide rolling updates, rollbacks, or declarative updates.
Usually not used directly; managed by Deployments.
Deployment
Manages ReplicaSets and provides declarative updates for Pods.
Supports rolling updates, rollbacks, and version history.
Allows you to update your application with zero downtime.
Recommended way to manage stateless applications.
Summary:
A Deployment manages ReplicaSets (and thus Pods), adding features like rolling updates and rollbacks.
Use Deployments for most use cases; use ReplicaSets directly only for advanced scenarios.
-------------------------------------------------------------------
7.Services
Establish connection between different applications like front and back end etc..
Different types of services:
a.Node port - Helps to map port on node and port on pod. whether single node in single pod or single node with multiple pods or multiple nodes with multple node.
k8s cluster  service creation is same and it will allow node IP to communicate webaapp inside the pod.
b.ClusterIP - Groups pods in to single type and allow to access the pods in the group. for example all front-end pods as one group then
provide single interface and back-end pods into one group then provide single interface.
And clusterIp service establish communication between these two groups. when request comes clusterIP communicate with one of the node randomly and 
provide access to the webapp running in that pod.
c.LoadBalancer - when end user want the URL in domain format instead of IP address, it is useful. This serves route traffic from external devices to app
which deployed in pod. Same as NodePort only difference can leverage using native loadbalancer support like AWS and Google cloud.
c.Headless Service 
in Kubernetes is a Service without a cluster IP (clusterIP: None). 
It allows direct access to the individual Pods behind the Service, rather than load-balancing traffic across them. 
This is useful for stateful applications like databases, where clients need to connect to specific Pods.
Headless Services are ideal when you need direct access to individual Pods, such as in clustered databases or stateful applications.
Use Cases
StatefulSets: Databases (e.g., Cassandra, MongoDB), where each Pod has a unique identity.
Direct Pod Discovery: Applications needing to discover and communicate with all Pods individually.
How It Works
No virtual IP is assigned.
DNS queries for the Service return the Pod IPs directly.
Clients can connect to specific Pods using DNS names like:
pod-name.my-db-headless.default.svc.cluster.local

Services - USE CASES:
1. ClusterIP (default)
Use case: Internal communication between Pods (e.g., frontend talks to backend).
Access: Only within the cluster.
2. NodePort
Use case: Expose an app to be accessible from outside the cluster (for development/testing).
Access: <NodeIP>:30080 from outside the cluster.
3. LoadBalancer
Use case: Expose an app to the internet with a cloud provider’s load balancer (production).
Access: External IP provided by the cloud provider.
4. Headless Service
Use case: Direct pod-to-pod communication (e.g., for databases, stateful sets).
Access: DNS resolves to individual pod IPs.
---------------------------------------------------------------------------------------------------------
8. Namespace
In Kubernetes (k8s), Namespaces are a way to divide cluster resources between multiple users or teams. 
They provide a mechanism for isolating groups of resources within a single cluster.
Key Points about Namespaces:
Isolation: Resources in different namespaces are isolated from each other.
Resource Quotas: You can set resource limits (CPU, memory) per namespace.
Name Scoping: Resource names (like pods, services) must be unique within a namespace, but not across namespaces.
Default Namespace: If you don’t specify a namespace, resources are created in the default namespace.
Common Namespaces
default: The default namespace for objects with no other namespace.
kube-system: For Kubernetes system components.
kube-public: Readable by all users (including unauthenticated users).
kube-node-lease: For node heartbeats.
#one resource in one namespace can communicate from another namespace
mysql.connect("<servicename>.<namespace name>.svc.cluster.local")
Here- cluster.local is kuberanates default domain
      svc is service
      
--------------------------------------------------------------------------------------------------------

