1.Pod:  Containers are encapsulated into a kubernates object. It is a single instance of appliaction.smallest object created in k8s.
      Single pod can have multiple containers and it should have different containers(not same).
       - additional containers use as helper container which used for if application need additional support for configurations or file processing  etc..
      Two containers communicate using local host and share volume
2.Replica: Prevent loosing access to application, will maintain more than on pod to run application. To achive high availability.
3.Replication contoller: This specifies number of specified pods create/run all time.
                       This also spin pods across nodes.
4.Replicaset: new version of replication contorller to achieve replication
            Monitors the pods health and deploy new pods if required
            Labels and selectors helps replicaSet to monitor pods. Based on labels and selectors Replicaset can identify which pods this need to monitor.
-------------------------------------------
ReplicationController is the older resource used to ensure a specified number of pod replicas are running at any time. 
It only supports equality-based selectors.

ReplicaSet is the newer, more advanced version that replaces ReplicationController. 
It supports both equality- and set-based selectors, allowing more flexible pod selection. ReplicaSet is used by Deployments to manage pods.

Summary:
ReplicaSet is the modern replacement for ReplicationController, offering more features and flexibility. 
ReplicationController is now deprecated in favor of ReplicaSet.
--------------------------------------------------------------
Equality-based selectors in Kubernetes are used to select resources (like pods) based on exact matches of label key-value pairs.            
                       
selector:
  matchLabels:
    app: nginx
This selector matches pods with the label app=nginx.

Supported operators:

= (equals)
== (equals)
!= (not equals)
Note:
Equality-based selectors do not support set-based operations like in, notin, or matching multiple values. Those are only available in set-based selectors.
---------------------------------------------------------------
5. Deployments
A Deployment in Kubernetes (k8s) is a resource object that manages a set of identical Pods, ensuring the desired number of them are running and up-to-date. Deployments are used for rolling updates, scaling, and rollback of applications.

Key Features
Declarative updates for Pods and ReplicaSets
Rollback to previous versions
Scaling up/down
Self-healing (replaces failed Pods)
----------------------------------------------------------
6. diff between deployemtns and replicase:
A Deployment and a ReplicaSet are both Kubernetes resources, but they serve different purposes:

ReplicaSet
Ensures a specified number of pod replicas are running at any time.
Only manages pod replication (creating, deleting pods).
Does not provide rolling updates, rollbacks, or declarative updates.
Usually not used directly; managed by Deployments.
Deployment
Manages ReplicaSets and provides declarative updates for Pods.
Supports rolling updates, rollbacks, and version history.
Allows you to update your application with zero downtime.
Recommended way to manage stateless applications.
Summary:
A Deployment manages ReplicaSets (and thus Pods), adding features like rolling updates and rollbacks.
Use Deployments for most use cases; use ReplicaSets directly only for advanced scenarios.
-------------------------------------------------------------------
7.Services
Establish connection between different applications like front and back end etc..
Different types of services:
a.Node port - Helps to map port on node and port on pod. whether single node in single pod or single node with multiple pods or multiple nodes with multple node.
k8s cluster  service creation is same and it will allow node IP to communicate webaapp inside the pod.
b.ClusterIP - Groups pods in to single type and allow to access the pods in the group. for example all front-end pods as one group then
provide single interface and back-end pods into one group then provide single interface.
And clusterIp service establish communication between these two groups. when request comes clusterIP communicate with one of the node randomly and 
provide access to the webapp running in that pod.
c.LoadBalancer - when end user want the URL in domain format instead of IP address, it is useful. This serves route traffic from external devices to app
which deployed in pod. Same as NodePort only difference can leverage using native loadbalancer support like AWS and Google cloud.


